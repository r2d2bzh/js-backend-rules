/* eslint-disable security/detect-non-literal-fs-filename */

import { promises as fs } from 'node:fs';
import { join as path, dirname, relative } from 'node:path';
import process from 'node:process';
import { findUp } from 'find-up';
import { green, yellow, red } from 'kleur/colors';
import { install as jsRules, readJSONFile, extractPackageDetails } from '@r2d2bzh/js-rules';
import tweakPackageJSON from './tweak-package-json.js';
import tweakConfigurationFiles from './tweak-configuration-files/index.js';
import { emptyObjectOnException, findDirectoriesWith, getProjectPath, readYAMLFile, spawn } from './utils.js';

const discardedServiceDirectories = new Set(['.', 'dev', 'share', 'test']);

export const install = async ({ logger = console, ...options } = {}) => {
  const colorizedLogger = options.color
    ? {
        log: (...arguments_) => logger.log(green(arguments_.join(' '))),
        warn: (...arguments_) => logger.warn(yellow(arguments_.join(' '))),
        error: (...arguments_) => logger.error(red(arguments_.join(' '))),
      }
    : logger;
  const { logPreamble, ...projectData } = await logOnFail(colorizedLogger, async () => {
    if (options.gitParent) {
      await cwdToGitParent();
    }
    return gatherProjectData(colorizedLogger);
  })();
  const loggerWithPreamble = {
    log: (...arguments_) => colorizedLogger.log(logPreamble, ...arguments_),
    warn: (...arguments_) => colorizedLogger.warn(logPreamble, ...arguments_),
    error: (...arguments_) => colorizedLogger.error(logPreamble, ...arguments_),
  };
  await logOnFail(loggerWithPreamble, async () => {
    await _install({ logger: loggerWithPreamble, ...projectData, ...options });
    loggerWithPreamble.log('successfully deployed');
  })();
};

const logOnFail =
  (logger, function_) =>
  async (...arguments_) => {
    try {
      return await function_(...arguments_);
    } catch (error) {
      logger.error('deployment failure -', error);
      throw error;
    }
  };

const cwdToGitParent = async () => {
  const gitParent = await findUp(
    async (directory) => {
      try {
        const gitStat = await fs.stat(path(directory, '.git'));
        return gitStat.isDirectory() && directory;
      } catch {
        return;
      }
    },
    {
      type: 'directory',
    },
  );
  if (gitParent) {
    process.chdir(gitParent);
  } else {
    throw new Error('no git parent directory found');
  }
};

const gatherProjectData = async (logger) => {
  const jsrStrings = await jsRulesStrings(logger);
  return {
    ...jsrStrings,
    ...(await findComponents(jsrStrings.logPreamble, logger)),
  };
};

const jsRulesStrings = (logger) =>
  extractPackageDetails({
    url: import.meta.url,
    extract: ({ name, version }) => ({
      logPreamble: `${name}[${version}]:`,
      editWarning: `DO NOT EDIT THIS FILE AS IT IS GENERATED BY ${name}`,
      scaffolderName: name,
    }),
    logger,
  });

const findComponents = async (logPreamble, logger) => {
  const [packages, dockerContexts] = await Promise.all(
    ['package.json', 'Dockerfile'].map((glob) => findDirectoriesWith(glob)),
  );
  return {
    serviceDirectories: packages
      .filter((p) => dockerContexts.includes(p))
      .filter(
        warnPredicate(
          (p) => `${logPreamble} deep service ${p} is discarded`,
          (p) => !p.includes('/'),
          logger,
        ),
      )
      .filter(
        warnPredicate(
          (p) => `${logPreamble} ${p} cannot be a service`,
          (p) => !discardedServiceDirectories.has(p),
          logger,
        ),
      ),
    subPackages: packages.filter((p) => p !== '.'),
  };
};

const warnPredicate = (warnFormatter, predicate, logger) => (x) => {
  const result = predicate(x);
  if (!result) {
    logger.warn(warnFormatter(x));
  }
  return result;
};

const _install = async ({
  logger,
  editWarning,
  scaffolderName,
  serviceDirectories,
  subPackages,
  npmInstall = true,
}) => {
  await structureProject({ logger, serviceDirectories });
  await tweakFiles({ logger, editWarning, scaffolderName, serviceDirectories, subPackages });
  if (npmInstall) {
    await dockerNpmInstall(logger)(['test-runner', ...serviceDirectories]);
  }
};

const structureProject = async ({ logger, serviceDirectories }) => {
  await ensureProjectDirectories();
  await Promise.all([
    ensurePackageJSONfiles(),
    ensureProjectSymlinks(
      [
        [path('test', '__tests__'), '__tests__'],
        ...serviceDirectories.map((directory) => [path('..', 'share'), path(directory, 'share')]),
      ],
      logger,
    ),
    ensureProjectFiles(
      [
        [
          path(relative(process.cwd(), dirname(new URL(import.meta.url).pathname)), 'js-backend-rules.adoc'),
          'js-backend-rules.adoc',
        ],
      ],
      logger,
    ),
  ]);
};

const ensureProjectDirectories = () =>
  Promise.all(
    ['dev', path('helm', 'templates'), 'share', path('test', '__tests__')].map((p) => fs.mkdir(p, { recursive: true })),
  );

const ensurePackageJSONfiles = () => Promise.all(['share', 'test'].map(spawn('npm', 'init', '-y')));

const ensureProjectItems = (addItem) => (items, logger) =>
  Promise.all(
    items.map(([source, destination]) =>
      fs
        .unlink(destination)
        .catch((error) => logger.warn(`${destination} was not unlinked (${error.message})`)) // path does not exist or is something we do not want to delete (dir...)
        .then(() => addItem(source, destination)),
    ),
  );

const ensureProjectSymlinks = ensureProjectItems(fs.symlink);

const ensureProjectFiles = ensureProjectItems(fs.copyFile);

const tweakFiles = async ({ logger, editWarning, scaffolderName, serviceDirectories, subPackages }) => {
  const [projectPath, projectDetails, helmChart] = await Promise.all([
    getProjectPath(),
    readJSONFile('package.json'),
    emptyObjectOnException(() => readYAMLFile(path('helm', 'Chart.yaml'))),
    tweakPackageJSON({ logger, serviceDirectories, subPackages }),
  ]);
  await jsRules({
    logger,
    editWarning,
    tweakConfigurationFiles: tweakConfigurationFiles({
      logger,
      projectPath,
      projectDetails,
      helmChart,
      editWarning,
      scaffolderName,
      subPackages,
      serviceDirectories,
    }),
    resultLogger: {
      log: () => {},
      error: () => {},
    },
  });
};

const dockerNpmInstall = (logger) => async (services) => {
  // We cannot operate parallel docker-compose runs for now:
  // https://github.com/docker/compose/issues/1516
  for (const service of services) {
    try {
      logger.log(await spawn('docker-compose', 'run', '--rm', '--entrypoint=""', service, 'npm', 'install')());
    } catch (error) {
      logger.error(error.message);
      throw error;
    }
  }
};
