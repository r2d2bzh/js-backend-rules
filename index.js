import { promises as fs } from 'fs';
import { createRequire } from 'module';
import path from 'path';
import FileHound from 'filehound';
import mixin from 'mixin-deep';
import { install as jsRules, toIgnore, toYAML } from '@r2d2bzh/js-rules';

// JSON import is still experimental and "--experimental-json-modules" cannot be implied
const require = createRequire(import.meta.url);
const packageJSON = require('./package.json');
const consumerPackageJSON = require(path.join(process.cwd(), 'package.json'));
const logPreamble = `${packageJSON.name}[${packageJSON.version}]:`;
const editWarning = `DO NOT EDIT THIS FILE AS IT IS GENERATED BY ${packageJSON.name}`;

const releaseItSubConfiguration = (packages) =>
  Object.fromEntries(
    packages.map((packDir) => [
      path.join(packDir, '.release-it.yaml'),
      {
        configuration: {
          npm: {
            publish: false,
          },
          git: {
            requireCleanWorkingDir: false,
            commit: false,
            tag: false,
            push: false,
          },
        },
        formatters: [toYAML(editWarning)],
      },
    ])
  );

const dockerConfiguration = (contexts) =>
  Object.fromEntries(
    contexts.map((context) => [
      path.join(context, '.dockerignore'),
      {
        configuration: ['node_modules'],
        formatters: [toIgnore(editWarning)],
      },
    ])
  );

const tweakConfigurationFiles =
  ({ subPackages, dockerContexts }) =>
  (f) => ({
    ...f,
    '.gitignore': {
      configuration: ['/package-lock.json', 'node_modules', 'test/coverage'],
      formatters: [toIgnore(editWarning)],
    },
    '.release-it.yaml': {
      configuration: {
        npm: {
          publish: false,
        },
        'before:bump': [
          "sed -i -e 's/${latestVersion}/${version}/g' helm/Chart.yaml",
          ...subPackages.map((pack) => `(cd ${pack} && release-it --ci \${version})`),
        ],
      },
      formatters: [toYAML(editWarning)],
    },
    ...releaseItSubConfiguration(subPackages),
    [path.join('dev', '.dockerignore')]: {
      configuration: ['*'],
      formatters: [toIgnore(editWarning)],
    },
    ...dockerConfiguration(dockerContexts),
    [path.join('helm', 'Chart.yaml')]: {
      configuration: {
        apiVersion: 'v1',
        name: consumerPackageJSON.name,
        version: consumerPackageJSON.version,
        description: consumerPackageJSON.description,
        appVersion: consumerPackageJSON.version,
      },
      formatters: [toYAML(editWarning)],
    },
  });

const findOwn = async (glob) =>
  (await FileHound.create().path(process.cwd()).discard('.*/node_modules/.*').match(glob).find())
    .map((p) => p.slice(process.cwd().length + 1))
    .map((p) => path.dirname(p));

const structureProject = async () => {
  await Promise.all(
    ['dev', path.join('helm', 'templates'), path.join('test', '__tests__')].map((path) =>
      fs.mkdir(path, { recursive: true })
    )
  );
  await Promise.all(
    [[path.join('test', '__tests__'), '__tests__']].map(([target, path]) =>
      fs
        .unlink(path)
        .catch(() => {}) // path does not exist or is something we do not want to delete (dir...)
        .then(() => fs.symlink(target, path))
    )
  );
};

const readJSONFile = async (path) => {
  try {
    const json = await fs.readFile(path, { encoding: 'utf8' });
    return JSON.parse(json);
  } catch (e) {
    throw new Error(`failed to extract JSON from ${path} (${e.message})`);
  }
};

const writeJSONFile = async (path, content) => {
  try {
    await fs.writeFile(path, JSON.stringify(content, null, 2), { encoding: 'utf8' });
  } catch (e) {
    throw new Error(`failed to write JSON to ${path} (${e.message})`);
  }
};

const mixinJSONFile = async (path, ...objects) => {
  const original = await readJSONFile(path);
  return writeJSONFile(path, mixin(original, ...objects));
};

const packageScripts = ({ subProjects }) => ({
  'package.json': {
    scripts: {
      lint: 'eslint .',
      release: 'release-it',
      pretest: 'npm run lint',
      test: 'docker-compose run test',
      'test:debug': 'docker-compose run --publish 9229 test debug',
    },
  },
  [path.join('test', 'package.json')]: {
    scripts: {
      checkdeps: subProjects.reduce((s, p) => `${s} && (cd "${path.join('..', p)}" && npm i)`, 'true'),
      precov: 'npm run checkdeps',
      cov: 'c8 ava',
      prenocov: 'npm run checkdeps',
      nocov: 'ava',
      debug: 'ava debug --host 0.0.0.0',
    },
  },
});

const tweakFiles = async () => {
  const [packages, dockerContexts] = await Promise.all(['package.json', 'Dockerfile'].map(findOwn));
  const subPackages = packages.filter((p) => p !== '.');

  await Promise.all(
    Object.entries(packageScripts({ subProjects: subPackages.filter((p) => p !== 'test') })).map(([pack, scripts]) =>
      mixinJSONFile(path.join(process.cwd(), pack), scripts)
    )
  );

  await jsRules({
    logPreamble,
    editWarning,
    tweakConfigurationFiles: tweakConfigurationFiles({
      subPackages,
      dockerContexts: dockerContexts.filter((p) => p !== 'dev'),
    }),
    resultLogger: {
      log: () => {},
      error: () => {},
    },
  });
};

export const install = async () => {
  try {
    await structureProject();
    await tweakFiles();
    console.log(logPreamble, 'successfully deployed');
  } catch (e) {
    console.error(logPreamble, 'deployment failure -', e);
  }
};
